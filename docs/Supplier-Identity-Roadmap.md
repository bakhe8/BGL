# Supplier Identity & Matching Roadmap
> ملاحظة: المرجع النهائي الملزِم هو مستند SIM-UFS v1.0 (`docs/Supplier-Identity-Model-UFS.md`). تبقى هذه الخريطة كمصدر خلفي للأفكار، لكن الأسماء والجداول والعتبات النهائية تعتمد على UFS. (تم تحديثها لتتوافق مع المنطق الجديد: الإدخال الحر يتطلب قرار صريح، لا حفظ تلقائي، وإنشاء مورد جديد فقط عند عدم وجود مرشحات وبعد ضغط زر واضح).
مرجع رسمي لتحسين منطق الموردين دون كسر النظام الحالي. يشمل المشكلة، الهدف، تعديلات الـ DB والمنطق، خارطة المراحل، والسيناريوهات.

---
## 0) الهدف العام (محدّث)
- نظام يتعلم من قرار المستخدم مع إدخال حر:  
  - مرشح ≥0.80 → يجب اختيار/رفض صريح؛ لا حفظ تلقائي، ولا إنشاء جديد بوجود مرشحات.  
  - لا مرشحين ≥0.80 → يمكن إنشاء مورد جديد فقط بعد ضغط زر واضح مع منع تكرار صارم.  
- ضوضاء أقل (رفع عتبة الفزي، منع إنشاء مع وجود مرشحات).  
- أمان أعلى (منع التكرار، تجميد العرض، تطبيع موحّد).  
- استقرار تاريخي (اسم المورد لا يتغير في السجلات القديمة).  
- الحظر (blocked) يستخدم فقط عند رفض مرشح معيّن.

---
## 1) المشكلة السابقة (للتاريخ)
- عدم وجود تعلم منظّم، ضوضاء في البدائل، عتبة فزي منخفضة، إمكانية إنشاء موارد مكررة، لا تجميد عرض. (تمت معالجتها في المنطق الجديد).

---
## 2) الأهداف (محدّثة)
- منع إنشاء مورد جديد إذا وُجد مرشح ≥0.80 (يُلزم اختيار/رفض).  
- إنشاء مورد جديد فقط عند انعدام أي مرشح ≥0.80، وبعد زر “إنشاء مورد جديد”، مع طول ≥5 ومنع تكرار ≥0.90.  
- التعلّم يتم عند قرار المستخدم (alias عند القبول، blocked عند الرفض).  
- تجميد اسم المورد في السجل لحماية الماضي.  
- تبسيط الواجهة لاحقاً دون مخاطرة.

---
## 3) تعديلات قاعدة البيانات (مختصر بعد التحديث)
- Legacy: يجب توليد normalized_name و supplier_normalized_key (طول ≥5) لكل مورد قديم قبل التشغيل، وأي مورد لا يمكن توليد مفتاح صالح له يُرفض في المطابقة حتى يُصحَّح.
- `supplier_aliases_learning`: للتعلّم (alias و blocked بحسب قرار المستخدم، مع upsert لآخر قرار).  
- `imported_records`: حقل `supplier_display` لتجميد الاسم.  
- `suppliers`: حقل إلزامي `supplier_normalized_key` بلا مسافات، طول ≥5.  
- فهارس على normalized_name / supplier_normalized_key / البدائل / التعلم.  
- منع التكرار: similarity ≥0.90 تمنع الإنشاء، طول ≥5 إلزامي.

---
## 4) التطبيع (Normalization)
- استخدام Normalizer::normalizeName (حروف صغيرة، توحيد همزات/تاء مربوطة، إزالة الرموز، دمج المسافات).
- خيار إضافة normalizeSupplierKey لتوليد normalized_key ثابت من الاسم الرسمي (اختياري).

---
## 5) المطابقة (Matching) – بالمنطق الجديد
1) Learning (alias/blocked)  
2) Overrides  
3) Exact by supplier_normalized_key  
4) Exact by normalized_name  
5) البدائل  
6) Fuzzy Strong/Weak (≥0.80، <0.80 يُهمل)  
**القرار يتطلب تفاعل المستخدم:**  
- إذا وجد مرشح ≥0.80:  
  - يجب اختيار مرشح (→ alias) أو رفض مرشح محدد (→ blocked)؛ لا حفظ تلقائي.  
  - لا يُنشأ مورد جديد بوجود مرشحات.  
- إذا لا مرشحين ≥0.80: يسمح بإنشاء مورد جديد بعد زر “إنشاء مورد جديد” مع القيود (normalize، key بلا مسافات، طول ≥5، similarity <0.90).

---
## 6) طبقة التعلّم للموردين (محدّثة)
- التسجيل عند قرار المستخدم فقط:  
  - اختيار مرشح ≥0.80 → alias للمورد المختار.  
  - رفض مرشح معيّن → blocked لذلك المورد.  
- upsert على normalized_input لجعل آخر قرار هو الحقيقة.  
- التعلّم يُستخدم أولاً في المطابقة لتقليل أي إعادة مراجعة.

---
## 7) حوكمة منع التكرار والدمج
- إنشاء مورد جديد فقط إذا لا مرشحين ≥0.80، وبعد زر واضح.  
- طول ≥5، similarity <0.90 على supplier_normalized_key إلزامي قبل الإنشاء.  
- normalized_key بلا مسافات، إلزامي.  
- لا حفظ خام بلا ربط؛ القرار دوماً اختيار/رفض/إنشاء جديد بقرار المستخدم.

---
## 8) الاسم الثابت (Display Freeze)
- حقل `supplier_display` في imported_records:
  - يُعبّأ عند القرار التلقائي (اختيار/alias أو إنشاء جديد).  
  - العرض يعتمد عليه أولاً؛ يحمي السجلات القديمة من تغيّر القاموس.

---
## 9) السيناريوهات المتوقعة
- اسم جديد واضح: إذا لا مرشحات ≥0.80 يمكن إنشاء مورد جديد (مع فحص الطول والتكرار) ثم تجميد supplier_display.
- اسم متكرر/قريب: التطبيع يطابق مورد موجود؛ اختيار نفس المورد → alias، لا تتكرر المشكلة.
- إضافة مورد جديد: إنشاء وربط السجل من نفس الحقل عند غياب المرشحات، العرض يتجمّد.
- رفض الاسم: رفض مرشح محدد → تسجيل blocked لتجنب عرضه مجدداً؛ إذا اختفت المرشحات يمكن إنشاء جديد.
- تعديل مورد لاحقاً: لا يؤثر على السجلات القديمة (supplier_display مجمّد)؛ المطابقة المستقبلية تستخدم الاسم الجديد.

---
## 10) خارطة المراحل (بدون كسر النظام)
### المرحلة 1: رفع جودة المطابقة
- رفع عتبة الفزي (≥0.80 كحد أدنى للعرض، strong/weak بحسب العتبة).  
- منع إنشاء مورد جديد عند وجود أي مرشّح ≥0.80.

### المرحلة 2: طبقة التعلم
- إنشاء/تفعيل supplier_aliases_learning.  
- دمجها في matching (فحص التعلم قبل القاموس).  
- تسجيل alias/blocked عند قرار المستخدم.

### المرحلة 3: قرار المستخدم (إدخال حر)
- إذا مرشح ≥0.80: يجب اختيار أو رفض؛ لا حفظ تلقائي ولا إنشاء جديد.  
- إذا لا مرشح ≥0.80: يمكن إنشاء مورد جديد من نفس الحقل، مع منع تكرار وطول ≥5 (التشابه ≥0.90 على normalized_key يمنع).

### المرحلة 4: تجميد العرض
- تعبئة supplier_display عند القرار (اختيار/alias أو إنشاء جديد).  
- استخدامه للعرض لحماية السجلات القديمة.

### المرحلة 5: ضبط الواجهة
- واجهة كتابة + dropdown؛ الحفظ يتطلب قرار المستخدم (اختيار/رفض/إنشاء جديد).

---
## 11) التسمية المقترحة (جداول/دوال)
- الجداول: supplier_aliases_learning، supplier_alternative_names، suppliers، imported_records (supplier_display).
- الدوال/Repositories (أمثلة):
  - findLearningByNormalizedSupplier, upsertSupplierLearningAlias, upsertSupplierLearningBlocked.
  - freezeSupplierDisplay(recordId, supplierName) – اختياري لتجميد العرض.
- الحقول الجديدة: normalized_key (اختياري في suppliers)، supplier_display (في imported_records).

---
## 12) نقاط حساسة
- دمج الأزرار قبل الحوكمة والتعلم والتجميد يزيد خطر التكرار والربط الخاطئ.
- رفع العتبة يقلل الضوضاء لكن قد يقلل المرشحين؛ فصل الفزي عن الرسمي ضروري لتحذير المستخدم.
- طبقة التعلم تُستخدم فقط بعد قرار المستخدم (لا تعلم تلقائي أثناء الاستيراد).
- supplier_display يحمي السجلات القديمة؛ بدونه قد تتغير الأسماء عند تعديل القاموس.

---
## 13) النتيجة المرجوة
- قاموس موردين أنظف وأقل تكراراً.
- مطابقة أدق وضوضاء أقل.
- قرارات المستخدم تصبح تعلّم (alias/blocked) يقلل “needs_review” المتكرر.
- السجلات القديمة محمية عبر supplier_display.
- واجهة أبسط لاحقاً (زر إدارة المورد) دون مخاطرة بعد تثبيت المنطق.
